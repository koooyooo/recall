meta:
  deck:
    ja: "SDI アルゴリズムとデータ構造"
    en: "SDI Algorithms & Data Structures"
  lang: "ja"
cards:
  - id: snowflake
    term:
      ja: "Snowflake ID"
      en: "Snowflake ID"
    definition: "Snowflake IDは、timestamp+shard+sequenceの順序性IDです。"
    explanation: "Snowflake IDは、Twitter社が開発した、分散システムでユニークかつ大まかにソート可能な64ビットIDを生成するアルゴリズムです。IDは、タイムスタンプ部、ワーカーID部、シーケンス番号部から構成されます。時間でソートできるためDBのインデックス効率が良いですが、タイムスタンプ部から生成時刻が推測できるため、セキュリティ要件によっては使用に注意が必要です。分散環境でのユニークID生成に広く利用されています。"
    tags: [id, algorithm]
    notes:
      - "IDの枯渇問題が起きにくく、スケーラブル"
      - "生成時刻がIDに含まれるため、ソート可能"
      - "ワーカーIDにより、複数のノードでユニークなIDを生成できる"
      - "セキュリティ要件によっては、生成時刻が推測されるリスクがある"
    url:
      - "https://en.wikipedia.org/wiki/Snowflake_ID"

  - id: uuid4
    term:
      ja: "UUID v4"
      en: "UUID v4"
    definition: "UUID v4は、128bitランダムIDです。"
    explanation: "UUID (Universally Unique Identifier) v4は、乱数に基づいて生成される128ビットの識別子です。その組み合わせの数は天文学的に巨大であるため、全世界で生成しても衝突する確率は無視できるほど小さいです。完全にランダムであるため、順序性はありません。URLセーフにするためにBase62などでエンコードされることもあります。分散システムにおけるユニークな識別子として広く利用されており、衝突の心配がほとんどないのが特徴です。"
    tags: [id, algorithm]
    notes:
      - "生成が容易で外部依存がないが、長くて（36文字）人間には読みにくい"
      - "完全にランダムなため、生成時刻や順序性はない"
      - "衝突確率は非常に低く、実質的にユニーク"
      - "データベースの主キーとして利用されることもあるが、インデックス効率は悪い場合がある"
    url:
      - "https://en.wikipedia.org/wiki/Universally_unique_identifier"

  - id: base62
    term:
      ja: "Base62"
      en: "Base62"
    definition: "Base62は、0-9a-zA-Zの62進表現です。"
    explanation: "Base62は、数値を62種類の英数字（0-9, a-z, A-Z）だけを使って表現するエンコーディング方式です。バイナリデータをテキストで表現するBase64と似ていますが、URLで特別な意味を持つ記号（+, /, =）を含まないため、URL短縮サービスのIDなど、人間が読み書きする短い文字列に適しています。短い文字列で多くの情報を表現できるため、URL短縮サービスや、ユニークなIDの表現などに利用されます。"
    tags: [encoding, algorithm]
    notes:
      - "大文字小文字を区別しないシステムでは使えないので注意"
      - "URLセーフな文字のみを使用"
      - "Base64よりも短い文字列で表現できる場合がある"
      - "主に短いIDやハッシュ値の表現に利用される"

  - id: bloom
    term:
      ja: "Bloom Filter"
      en: "Bloom Filter"
    definition: "Bloom Filterは、存在しない可能性を高速に判定するデータ構造です。"
    explanation: "Bloom Filterは、ある要素が集合に含まれているかどうかを、非常に省スペースで高速に判定するための確率的データ構造です。「含まれていない」という判定（偽陰性）は常に正しいですが、「含まれている」という判定（偽陽性）は間違っている可能性があります。LSM-Treeでは、SSTableを読みに行く前にBloom Filterでチェックすることで、存在しないキーに対する不要なディスクI/Oを削減します。キャッシュの最適化、データベースの存在チェック、ネットワークルーティングなど、様々な分野で利用されます。"
    tags: [algo, storage, algorithm]
    notes:
      - "要素を追加することはできるが、削除することはできない（Counting Bloom Filterなどの派生形を除く）"
      - "偽陽性率を許容することで、メモリ使用量を大幅に削減できる"
      - "データが存在しないことを高速に判定できるのが最大のメリット"
      - "LSM-Treeの読み取り性能向上に貢献"
    url:
      - "https://en.wikipedia.org/wiki/Bloom_filter"

  - id: consistent-hashing
    term:
      ja: "Consistent Hashing (一貫性ハッシュ)"
      en: "Consistent Hashing"
    definition: "ノードの追加や削除があっても、キーとノードのマッピングの変更を最小限に抑えるハッシュ手法です。"
    explanation: "Consistent Hashingは、分散キャッシュや分散データベースなどで、ノードの追加・削除時にデータ再配置（リシャーディング）のコストを最小限に抑えるために使用されます。通常のハッシュではノード数が変わるとほとんど全てのキーのマッピングが変更されますが、Consistent Hashingでは、ハッシュリング上にキーとノードを配置し、ノードの追加・削除があっても影響を受けるのはリング上の隣接ノードにマッピングされたキーのみとなります。これにより、大規模なデータ再配置を避け、システムの可用性とスケーラビリティを向上させます。"
    tags: [algorithm, distributed, caching]
    notes:
      - "ハッシュリング（円環）上にキーとノードを配置する"
      - "仮想ノード（Virtual Nodes）を導入することで、負荷分散の偏りを軽減できる"
      - "ノードの追加・削除時のデータ移動量を最小化する"
      - "代表例: Dynamo, Cassandra, Riakなどの分散システム"
    url:
      - "https://en.wikipedia.org/wiki/Consistent_hashing"

  - id: merkle-tree
    term:
      ja: "Merkle Tree (ハッシュツリー)"
      en: "Merkle Tree"
    definition: "データのブロックのハッシュ値を階層的に結合して作られるツリー構造で、データの整合性や変更を効率的に検証するために使用されます。"
    explanation: "Merkle Treeは、リーフノードが個々のデータブロックのハッシュ値を持ち、親ノードがその子ノードのハッシュ値を結合したハッシュ値を持つツリー構造です。ツリーのルートにあるハッシュ値（Merkle Root）は、全てのデータブロックの整合性を代表します。データブロックの一部が変更された場合、その変更はツリーを遡ってルートハッシュに伝播するため、ルートハッシュを比較するだけでデータ全体の整合性を効率的に検証できます。また、特定のデータブロックの存在証明や、異なるデータセット間の差分検出にも利用されます。"
    tags: [algorithm, distributed, data-structure, security]
    notes:
      - "ブロックチェーン技術の基盤の一つ（トランザクションの整合性検証に利用）"
      - "P2Pネットワークでのファイル同期（例: BitTorrent）や、分散データベースでのデータ整合性チェックに利用される"
      - "データの一部が変更された場合でも、変更された部分のみを再計算すればよいため効率的"
      - "ルートハッシュのみを共有することで、大量のデータを効率的に検証できる"
    url:
      - "https://en.wikipedia.org/wiki/Merkle_tree"
